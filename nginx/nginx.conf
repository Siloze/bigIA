worker_processes auto;

events {
    worker_connections 1024;
}

http {
    # Dictionnaire partagé pour la lib JWT
    lua_shared_dict jwt_cache 10m;

    # Inclure les libs Lua dans le path
    lua_package_path "/usr/local/openresty/lualib/?.lua;;";

    server {
        listen 443 ssl;
        server_name monia.entreprise.local;

        #####################################################
        # SSL / TLS Configuration
        #####################################################
        ssl_certificate     /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;

        #####################################################
        # SSO via Active Directory (Kerberos avec SPNEGO)
        #####################################################
        auth_gss on;  # Active l’authentification Kerberos (SPNEGO)
        auth_gss_keytab /etc/nginx/http.keytab;  # Clé Kerberos du service
        auth_gss_realm ENTREPRISE.LOCAL;         # Domaine Active Directory
        auth_gss_service_name HTTP;              # Nom du service Kerberos

        #####################################################
        # 1. Servir l'application Angular
        #####################################################
        root /var/www/angular;
        index index.html;

        # Toutes les routes HTML de l'app Angular vont vers index.html
        location / {
            try_files $uri $uri/ /index.html;
        }

        #####################################################
        # 2. Reverse proxy des appels API + Signature JWT
        #####################################################
        location /api/ {
            #################################################
            # Étape : Génération du JWT
            #################################################
            access_by_lua_block {
                local jwt = require("resty.jwt")
                local cjson = require("cjson")

                -- Récupérer l'identité depuis l'auth Kerberos
                local user = ngx.var.remote_user or "anonymous"
                -- Ici on pourrait mapper les groupes AD à des rôles
                local role = "user"

                -- Charger la clé privée pour signer le JWT
                local f = assert(io.open("/etc/nginx/jwt_signing.key"))
                local private_key = f:read("*all")
                f:close()

                -- Créer le JWT (expire dans 60 secondes)
                local token = jwt:sign(private_key, {
                    header = {
                        typ = "JWT",
                        alg = "RS256",
                        kid = "v1"
                    },
                    payload = {
                        sub = user,                -- utilisateur authentifié
                        role = role,              -- rôle mappé depuis AD
                        iss = "nginx-gateway",    -- qui émet le JWT
                        aud = "api-management",   -- à qui il est destiné
                        exp = ngx.time() + 60     -- expiration
                    }
                })

                -- Ajouter le token dans les headers de la requête
                ngx.req.set_header("Authorization", "Bearer " .. token)
            }

            #################################################
            # Étape : Reverse Proxy vers l’API de gestion
            #################################################
            proxy_pass https://api_management.internal;

            # Headers utiles à conserver
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}